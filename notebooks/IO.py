from functions import *from utils import *class IO(object):    def __init__(self):        self.computer = ""        self.executable_path = ""        self.data_path = ""        self.executable_name = ""    def getHist(self, data, binsize):        binnb = 0        val = []        for ind, i in enumerate(data):            if (ind%binsize)==0:                if binnb > 0:                    val.append(accumulator)                accumulator = 0                binnb +=1            else:                accumulator+=i        return val    def runPSTH(self, N=300, r = 0.8, G=3, S=50, it=8,                binsize=1000, d1=10000, d2=60000,                d3=25000, before=10000, after=85000,                s=60, WII=1400, LTP = 1, LTD = 1, model = 'cc-izh'):        Parallel(n_jobs=num_cores)(delayed(self.runSimulation)(N,r, i,G,S,                                                               d1, d2, d3, before, after,                                                               s, WII, LTP, LTD, model) for i in range(it))    def readPSTH(self, N, r, G, S, it,                 binsize, d1, d2,                 d3, before, after,                 s, WII, LTP, LTD, model, coeff, RON='izh', tau_m=10):        gr = GRAPH()        listSSP1 = Parallel(n_jobs=num_cores)(delayed(self.readSimulationSSP1)(N, r,i,G,S,                                                                               d1, d2, d3, before, after,                                                                               WII, LTP, LTD, model) for i in range(it))        if RON == 'izh':            listS = Parallel(n_jobs=num_cores)(delayed(gr.readoutSpikes)(ssp1, coeff, tau_m) for ssp1 in listSSP1)        else:            listS = Parallel(n_jobs=num_cores)(delayed(gr.readoutSpikesIAF)(ssp1, coeff, tau_m) for ssp1 in listSSP1)        tot = np.sum(listS, axis=0)        totSSP1 = np.sum(listSSP1, axis=0)        total = np.sum(listS)        h = self.getHist(tot,binsize)        hSSP1 = self.getHist(totSSP1,binsize)        spikes_x, spikes_y, spikes_x_tc, spikes_y_tc, gamma, correlation, ssp1, stimulation,p,q,lowsp,vm = self.readSimulation(N,r,0,G,S, d1, d2, d3, before, after, WII, LTP, LTD, model)        return h, stimulation, total, hSSP1, totSSP1    def runSimulation(self, N = 100, r=0.8,i=0, G=3 ,S=100, d1=1000, d2=2000, d3=1000, before=2000, after=1000, s=60, WII=500, LTP=0, LTD=0, model='izh'):        ext = "_%d.txt"%i        sh.cd(self.executable_path)        subprocess.check_output([self.executable_name, '-N', str(N), '-ext', str(ext),                                '-d1', str(d1), '-d2', str(d2), '-d3', str(d3) ,                                '-before', str(before), '-after', str(after),                                 '-S', str(S),  '-G', str(G), '-s', str(s),                                 '-WII', str(WII), '-LTP', str(LTP), '-LTD', str(LTD),                                  '-model', model, '-r', str(r)])    def readSimulationSSP1(self, N, r, i, G,S, d1, d2, d3, before, after, WII, LTP, LTD, model):        T = d1+d2+d3        DIRECTORY = self.data_path        # simulation parameters        g = G        TImean = 30        glob = 1        N = N        ext = "_%d.txt"%i        # compute the paths of data files.        extension = "_g-%.6g_TImean-%d_T-%d_Glob-%d_dt-0.25_N-%d_r-%.2g_S-%d_WII-%d_LTD-%.6g_LTP-%.6g_model-%s" \                    % (g, TImean,T, glob, N, r, S, WII, LTD, LTP, model)        extension += ext        ssp1_p = DIRECTORY + "ssp"+ extension        ssp1 = np.fromfile(ssp1_p, dtype='double', count = -1, sep=" ")        return ssp1    def readSimulation(self, N, r, i, G,S, d1, d2, d3, before, after, WII, LTP, LTD, model):        T = d1+d2+d3        DIRECTORY = self.data_path        # simulation parameters        g = G        TImean = 30        glob = 1        N = N        dt = 0.25        ext = "_%d.txt"%i        # compute the paths of data files.        extension = "_g-%.6g_TImean-%d_T-%d_Glob-%d_dt-0.25_N-%d_r-%.2g_S-%d_WII-%d_LTD-%.6g_LTP-%.6g_model-%s" \                    % (g, TImean,T, glob, N, r, S, WII, LTD, LTP, model)        extension += ext        path_x  = DIRECTORY + "spike_x" + extension        path_x_tc  = DIRECTORY + "spike_x_tc" + extension        path_y  = DIRECTORY + "spike_y"+ extension        path_y_tc  = DIRECTORY + "spike_y_tc"+ extension        path_g  = DIRECTORY + "gamma"+ extension        path_c  = DIRECTORY + "correlation"+ extension        ssp1_p = DIRECTORY + "ssp"+ extension        p_p = DIRECTORY + "p"+ extension        q_p = DIRECTORY + "q"+ extension        lowsp_p = DIRECTORY + "LowSp"+ extension        vm_p = DIRECTORY + "vm"+ extension        #ssp2_p = DIRECTORY +"ssp2"+ extension        #ssp3_p = DIRECTORY +"ssp3"+ extension        RON_I_p = DIRECTORY +"RON_I"+ extension        RON_V_p = DIRECTORY +"RON_V"+ extension        V_p = DIRECTORY +"V"+ extension        stimulation_p = DIRECTORY +"stimulation"+ extension    #     print path_g        try:            spikes_x = np.fromfile(path_x, dtype='uint',count =  -1, sep =" ")            spikes_x_tc = np.fromfile(path_x_tc, dtype='uint',count =  -1, sep =" ")            spikes_y = np.fromfile(path_y, dtype='uint',count =  -1, sep =" ")            spikes_y_tc = np.fromfile(path_y_tc, dtype='uint', count = -1, sep=" ")            gamma = np.fromfile(path_g, dtype='double', count = -1, sep=" ")            correlation = np.fromfile(path_c, dtype='double', count = -1, sep=" ")            ssp1 = np.fromfile(ssp1_p, dtype='double', count = -1, sep=" ")            p = np.fromfile(p_p, dtype='double', count = -1, sep=" ")            q = np.fromfile(q_p, dtype='double', count = -1, sep=" ")            LowSp = np.fromfile(lowsp_p, dtype='double', count = -1, sep=" ")            vm = np.fromfile(vm_p, dtype='double', count = -1, sep=" ")            #ssp2 = np.fromfile(ssp2_p, dtype='double', count = -1, sep=" ")            #ssp3 = np.fromfile(ssp3_p, dtype='double', count = -1, sep=" ")            stimulation = np.fromfile(stimulation_p, dtype='double', count = -1, sep=" ")            return spikes_x, spikes_y, spikes_x_tc, spikes_y_tc, gamma, correlation, ssp1, stimulation, p, q, LowSp, vm        except:            print('can\' find:\t '+ path_g)class Cortex(IO):    def __init__(self):        self.computer = "GP1514"        self.executable_path = "/Users/%s/Dropbox/ICL-2014/Code/C-Code/cortex/cortex/" % self.computer        self.data_path = "/Users/%s/Dropbox/ICL-2014/Code/C-Code/cortex/data/" % self.computer        self.executable_name = './cortex'class TRN(IO):    def __init__(self):        self.computer = "GP1514"        self.executable_path = "/Users/%s/Dropbox/ICL-2014/Code/C-Code/TRN/TRN/" % self.computer        self.data_path = "/Users/%s/Dropbox/ICL-2014/Code/C-Code/TRN/data/" % self.computer        self.executable_name = './trn'class GRAPH:    def readoutneuroncortex(self, ax, ssp1, Rm, W=-200, x=None):        dt = 0.25        bTh = 1.3        T   = len(ssp1)/4                  # total time to simulate (msec)        time    = np.arange(0, T, dt)        n = IzhNeuron("Burst Mode", a=0.02, b=0.25, c=-50, d=2, v0=-70)        s1 = IzhSim(n, T=T, dt=dt)        for i, t in enumerate(time):            s1.stim[i] = W*ssp1[i]        res = s1.integrate()        ax.set_ylim([-150,30])        ax.spines['left'].set_position('zero')        ax.spines['right'].set_color('none')        #ax.spines['bottom'].set_position('zero')        ax.spines['top'].set_color('none')        ax.xaxis.set_ticks_position('bottom')        ax.yaxis.set_ticks_position('left')        if x:            ax.set_xlabel('Time (msec)')        else:            ax.set_xticks([])        ax.plot(s1.t, res[0], label='membrane voltage [mV]')        return ax    def readoutSpikes(self, ssp1, W=-200):        dt = 0.25        T   = len(ssp1)/4                  # total time to simulate (msec)        time    = np.arange(0, T, dt)        # n = IzhNeuron("Burst Mode", a=0.02, b=0.25, c=-50, d=2, v0=-70)        n = IzhNeuron("(A) tonic spiking", a=0.02, b=0.2, c=-65, d=6, v0=-70)        s1 = IzhSim(n, T=T, dt=dt)        for i, t in enumerate(time):            s1.stim[i] = W*ssp1[i]        res = s1.integrate()        spikes = res[0]>0        return spikes    def readoutSpikesIAF(self, ssp1, W, tau_m=10):        ## setup parameters and state variables        T   = len(ssp1)/4             # total time to simulate (msec)        dt      = 0.25               # simulation time step (msec)        time    = np.arange(0, T, dt) # time array        t_rest  = 0                   # initial refractory time        ## LIF properties        Vm      = np.zeros(len(time))    # potential (V) trace over time        Rm      = W                   # resistance (kOhm)        Cm      = 7                  # capacitance (uF)        tau_m   = tau_m               # time constant (msec)        tau_ref = 4                   # refractory period (msec)        Vth     = 1                   # spike threshold (V)        V_spike = 0.5                 # spike delta (V)        ## Stimulus        I       = ssp1                 # input current (A)        ## iterate over each time step        for i, t in enumerate(time):            if t > t_rest:                Vm[i] = Vm[i-1] + (-Vm[i-1] + I[i]*Rm) / tau_m * dt            if Vm[i] >= Vth:                Vm[i] += V_spike                t_rest = t + tau_ref        # plt.plot(Vm)        spikes = Vm>1.1        return spikes    def findindex(self, val, spikes_x, start=0):        result = spikes_x[-1]        for i in range(start,len(spikes_x)):            if spikes_x[i] == val or spikes_x[i] > val:                result = i                break        return result    def plotraster(self, ax, spikes_x, spikes_y, i1, i2, dur=1000, end=0, x=0):        spx = spikes_x[i1:i2]        spy = spikes_y[i1:i2]        ax.spines['right'].set_color('none')        ax.spines['top'].set_color('none')        ax.xaxis.set_ticks_position('bottom')        ax.yaxis.set_ticks_position('left')    #     ax.set_ylim([0,100])        if x==0:            ax.set_xticks([])        else:            ax.set_xlabel('Time (msec)')        ax.plot(spx,spy,'.',markersize=1)    #    # def plotTransition(self, spikes_x, spikes_y, dur = 1000):    #     t1 = self.findindex(int(T/3)-dur, spikes_x)    #     t2 = self.findindex(int(T/3)+dur, spikes_x, t1)    #     t3 = self.findindex(int(2*T/3)-dur, spikes_x, t2)    #     t4 = self.findindex(int(2*T/3)+dur, spikes_x, t3)    #     t5 = self.findindex(int(3*T/3)-2*dur, spikes_x, t4)    #     t6 = len(spikes_x)    #    #     fig=plt.figure(figsize=(10,10))    #     ax1=fig.add_subplot(311)    #     ax1=self.plotraster(ax1, spikes_x, spikes_y, t1,t2,dur)    #     ax2=fig.add_subplot(312)    #     ax2=self.plotraster(ax2, spikes_x, spikes_y, t3,t4, dur)    #     ax3=fig.add_subplot(313)    #     ax3=self.plotraster(ax3, spikes_x, spikes_y, t5,t6, dur, 1, 1)    #    #     plt.savefig(DIRECTORY + extension + "transition_spikes_save.pdf")    def plotPTSH(self, fig, before, after,binsize, h, s, it, DIRECTORY, S, N):        T = before+after        simsize=T/0.25        x2 = np.arange(0,(simsize/4-1)/1000, (simsize/len(s)/4)/1000)        # fig = plt.figure(figsize=(9,5))        gs = gridspec.GridSpec(2, 1, height_ratios=[3, 1])        ax0 = plt.subplot(gs[0])        # ax0.set_ylim([0,10])        ax0.bar(np.arange(0,simsize/1000,simsize/len(h)/1000),np.array(h)/it, binsize/1000)        ax0.set_title('PSTH - Input: %s' % S)        ax0.set_xticks([])        # plot stimulation s        ax = plt.subplot(gs[1])        ax.set_ylim([30,110])        ax.set_yticks([30,100])        ax.set_xlabel('Time [s]')        plt.plot(x2,s)        plt.tight_layout()        extension = "_S-%d_N-%d_T-%d" % (S, N, T)        print(DIRECTORY + extension + '_PTSH.pdf')        plt.savefig(DIRECTORY + extension + '_PTSH.pdf')    def plotDiagram2(self, figure, ax, dataframe, title, column, filename, save=True, front=False, gridsize=60):        ax.set_ylim(ymin=50, ymax=250)        # Set color transparency (0: transparent; 1: solid)        a = 1        # Create a colormap        customcmap = [(x/24.0,  x/48.0, 0.05) for x in range(len(dataframe))]        dataframe.plot(kind="hexbin",                       y='nuEI', x='gammaC', C=column,gridsize=gridsize, ax=ax, alpha=a, legend=False, colormap=cx4,                              # edgecolor='w',                title=title)        ax.set_title(title, y=1.03)        # Customize title, set position, allow space on top of plot for title        # ax.set_title(ax.get_title(), fontsize=36, alpha=a)        # ax.title.set_fontsize(36)        plt.subplots_adjust(top=0.9)        # ax.title.set_position((0,1.08))        # Set x axis label on top of plot, set label text        ax.xaxis.set_label_position('bottom')        ax.set_xlim([0,7])        xlab = r'$\gamma_C$'        ylab = r'$\nu_{EI}$'        ax.set_xlabel(xlab, alpha=a)        ax.set_ylabel(ylab, alpha=a)        ax.set_xticklabels(ax.get_xticks(), alpha=a)        ax.set_yticklabels(ax.get_yticks(), alpha=a)        # plasticity trajectory        # x = spikingSimulation.gamma*spikingSimulation.N_I        # y = (spikingSimulation.stimulation+neuronI.N_mean)/(neuronI.V_th - neuronI.vReset)        # plt.plot(x,y)        if front:            dataframe['logburst']= (dataframe['burst']).apply(np.log10)            df_sliced = dataframe[(dataframe['logburst']>-6) & (dataframe['logburst']<-5.8)]            contour = df_sliced[['gammaC','nuEI']].get_values()            yvals, xvals = self.bezier_curve(contour, nTimes=100)            frontier = np.array([xvals,yvals])            ax.plot(frontier[1,:], frontier[0,:], '-w', linewidth=3)        if save:            plt.tight_layout()            plt.savefig(DIRECTORY + filename)        return ax    def plotDiagram(self, figure, ax, dataframe, title, column, filename, save=True, front=False, gridsize=60,                    extent = [0,7.0,0,200], cmap=cx4 ):        ax.set_ylim(ymin=0, ymax=extent[3])        # Set color transparency (0: transparent; 1: solid)        a = 1        # Create a colormap        customcmap = [(x/24.0,  x/48.0, 0.05) for x in range(len(dataframe))]        dataframe=dataframe.fillna(0)        nbVal  = len(pd.unique(dataframe.nuEI.ravel()))        da = np.array(dataframe[['gammaC','nuEI',column]].sort_values(['nuEI','gammaC'],ascending=[0, 1]))        z = da[:,2]        # print(z.shape)        try:            zr = z.reshape(nbVal,len(z)/nbVal)            print(zr.shape)            image = ax.imshow(zr,extent=extent, cmap=cmap, aspect=extent[1]/extent[3])#, cmap =cx4)# drawing the function            plt.colorbar(image,format='%.3g')            # ax.plot(frontier[1,:], frontier[0,:], '-w', linewidth=2)            ax.set_title(title, y=1.03)            # Customize title, set position, allow space on top of plot for title            # ax.set_title(ax.get_title(), fontsize=36, alpha=a)            # ax.title.set_fontsize(36)            plt.subplots_adjust(top=0.9)            # ax.title.set_position((0,1.08))            # Set x axis label on top of plot, set label text            ax.xaxis.set_label_position('bottom')            maxX = math.floor(extent[1]*10)/10            maxY = math.ceil(extent[3]/10)*10            ax.set_xlim([extent[0],maxX])            ax.set_yticks([extent[2],(maxY-extent[2])/2, maxY])            ax.set_xticks([extent[0],(maxX-extent[0])/2, maxX])            xlab = r'$\gamma_C$'            ylab = r'$\nu_{EI}$'            ax.set_xlabel(xlab, alpha=a)            ax.set_ylabel(ylab, alpha=a)            ax.set_xticklabels(ax.get_xticks(), alpha=a)            ax.set_yticklabels(ax.get_yticks(), alpha=a)            # plasticity trajectory            # x = spikingSimulation.gamma*spikingSimulation.N_I            # y = (spikingSimulation.stimulation+neuronI.N_mean)/(neuronI.V_th - neuronI.vReset)            # plt.plot(x,y)            if front:                dataframe['logburst']= (dataframe['burst']).apply(np.log10)                df_sliced = dataframe[(dataframe['logburst']>-6) & (dataframe['logburst']<-5.8)]                contour = df_sliced[['gammaC','nuEI']].get_values()                yvals, xvals = self.bezier_curve(contour, nTimes=100)                frontier = np.array([xvals,yvals])                ax.plot(frontier[1,:], frontier[0,:], '-w', linewidth=3)            if save:                plt.tight_layout()                plt.savefig(DIRECTORY + filename)        except:            print('Error reshaping array')        return ax    def savePTSH(self, before, after, h, s, it, DIRECTORY, S, N):        '''        Save PTSH data        '''        T = before+after        simsize=len(s)        print(T/1000, simsize, T/1000/simsize)        x2 = np.arange(0,T/1000, T/1000/simsize)        extension = "_S-%d_N-%d_T-%d" % (S, N, T)        np.save(DIRECTORY + extension + '_data.npy', np.array([np.arange(len(h)),np.array(h)/it]))    def func(self, x, a, b, c):        return a * np.exp(-b * x) + c    def plotRaster(self, spikes_x,spikes_y, ax=None):        if not ax:            f = plt.figure(figsize=(4,3))            ax = f.add_subplot(111)        ax.set_xticks([])        # ax.set_yticks([0,300])        # ax.set_xlabel('Time [1.5s]')        # ax.set_ylabel('Neuron indices [0-300]')        # ax.set_title('Neuronal Activity')        if ax==None:            plt.plot(spikes_x,spikes_y, '.', markersize=1)        else:            ax.plot(spikes_x,spikes_y, '.', markersize=1)        return ax        # plt.savefig(DIRECTORY + extension + '_raster.pdf')        # plt.savefig(DIRECTORY + extension + '_raster.png')    def plotRasterGPU(self, spikes_x, spikes_y, titlestr=""):        '''        Take advantage of WebGL to draw raster plot        '''        # output_file("spikesGPU.html", title="Neural activity")        p = figure(plot_width=1000, plot_height=500, webgl=True, title = titlestr)        if len(spikes_x) > 100000:            p.scatter(spikes_x[0:100000],spikes_y[0:100000], alpha=0.5)        else:            p.scatter(spikes_x, spikes_y, alpha=0.5)        # save(p, filename=titlestr)        show(p)    def fourier(self, signal):        f_val, p_val = self.maxPowerFreq(signal[int(signal.shape[0]/2):],0.25/1000)        return [f_val, p_val]    def maxPowerFreq(self, y, dt):        # return the max power of the signal and its associated frequency        fs = 1. / dt        y = y - np.mean(y)        t = np.arange(0, y.shape[0], 1)        p1,f1 = psd(y, NFFT=len(t), pad_to=len(t), Fs=fs)        powerVal = 10*np.log10(max(p1))        powerFreq = np.argmax(p1) * np.max(f1)/len(f1)        return powerFreq, powerVal    def bernstein_poly(self, i, n, t):        """         The Bernstein polynomial of n, i as a function of t        """        return comb(n, i) * ( t**(n-i) ) * (1 - t)**i    def bezier_curve(self, points, nTimes=1000):        """           Given a set of control points, return the           bezier curve defined by the control points.           points should be a list of lists, or list of tuples           such as [ [1,1],                     [2,3],                     [4,5], ..[Xn, Yn] ]            nTimes is the number of time steps, defaults to 1000            See http://processingjs.nihongoresources.com/bezierinfo/        """        nPoints = len(points)        xPoints = np.array([p[0] for p in points])        yPoints = np.array([p[1] for p in points])        t = np.linspace(0.0, 1.0, nTimes)        polynomial_array = np.array([ self.bernstein_poly(i, nPoints-1, t) for i in range(0, nPoints)   ])        xvals = np.dot(xPoints, polynomial_array)        yvals = np.dot(yPoints, polynomial_array)        return xvals, yvals    def frontgamma(self, nuEI, frontier, tol = 10):        '''        Return the value of GAMMA for a value of NUEI        '''        indices = np.where(np.logical_and(frontier[0]<=nuEI + tol, frontier[0]>=nuEI - tol))        return np.mean(frontier[1][indices[0]])    def find_nearest(self, array,value, dataframe):        gamma = (pd.unique(dataframe['gammaC']))        idx = (np.abs(array-value)).argmin()        return array[idx], idx, gamma[idx]    def fixpoint(self, df, nuEI, ratio, rule, g0 = 5):        '''        Search and return the fix point for a plasticity rule, or 0 if none        :param df:        :param nuEI:        :param ratio:        :param rule: [1 hardbound        2 softbound passive        3 softbound spiking no bursting        4 hardbound passive        5 hardbound spiking non bursting]        :param g0:        :return:        '''        LTP = 10        LTD = LTP * ratio        df_sliced = df[df['nuEI']==nuEI]        df_sliced = df_sliced.sort_values(by=['gammaC'])        bg = df_sliced[['burst','gammaC']].get_values()        sg = df_sliced[['spike','gammaC']].get_values()        rg = df_sliced[['non-burst','gammaC']].get_values()        df_sliced['passive'] = df_sliced['burst'].apply(lambda x :1-x)        passive = df_sliced[['passive','gammaC']].get_values()    #     sg = 1 - np.array(bg)        cg =  df_sliced[['corI','gammaC']].get_values()        if rule == 1:            dG = LTP * sg[:,0] - LTD * bg[:,0]        elif rule == 4:            dG = LTP * passive[:,0] - LTD * bg[:,0]        elif rule == 5:            dG = LTP * rg[:,0] - LTD * bg[:,0]        elif rule ==0:            dG = LTP * (g0 - sg[:,1] )/g0 * sg[:,0] - LTD * bg[:,0]        elif rule ==2:            dG = LTP * (g0 - passive[:,1] )/g0 * passive[:,0] - LTD * bg[:,0]        elif rule ==3:            dG = LTP * (g0 - rg[:,1] )/g0 * rg[:,0] - LTD * bg[:,0]        res = 0        dg2 = np.array(dG)        if (dg2 > 0).all() or (dg2 < 0).all():            res = 0        else:            minval , idx,_ =  self.find_nearest(dg2,0,df)            res = sg[idx,1]        return res    def overunder(self, df, frontier, rule):        '''        return 0 if fixpoint over in the SYNC regime, 1 otherwise        '''        if rule in [0,1,5,3]:            col = np.arange(3,5,0.05) #ratio for active rule        else:            col = np.arange(60,180,3) #ratio for passive rule        row = np.arange(0,200,1) #nu        Z = np.zeros(shape=(len(row),len(col)))        for i,ratio in enumerate(col):            for j, nuEI in enumerate(row):                f= self.fixpoint(df, nuEI, ratio, rule)                border = self.frontgamma(nuEI, frontier)                Z[len(row)-1-j,i] = abs(f-border)*((f<border) and (f>0.15) and (nuEI>48))*1.0        return Z    def plotStability(self, ax, Z, ylabel, title, extent):        cx_blue = cubehelix.cmap(reverse=False, start=3., rot=0)        ax.set_xlabel('ratio')        ax.set_ylabel(r'Excitatory input $\nu$')        ax.set_title('Hard. all-spiking', y=1.08)        image = ax.imshow(Z, interpolation='nearest', extent=extent,cmap=cx_blue, aspect=2/200)#, cmap =cx4)# drawing the function        plt.colorbar(image)        return ax################################################################################# Classes################################################################################class IzhNeuron:  def __init__(self, label, a, b, c, d, v0, u0=None):    self.label = label    self.a = a    self.b = b    self.c = c    self.d = d    self.v = v0    self.u = u0 if u0 is not None else b*v0class IzhSim:    def __init__(self, n, T, dt=0.1):        self.neuron = n        self.dt     = dt        self.t      = t = np.arange(0, T+dt, dt)        self.stim   = np.zeros(len(t))        self.x      = 5        self.y      = 140        self.du     = lambda a, b, v, u: a*(b*v - u)    def integrate(self, n=None):        if n is None: n = self.neuron        trace = np.zeros((3,len(self.t)))        b = 2        p = 0        tau_p = 10        for i, j in enumerate(self.stim):        #       n.v += self.dt * (0.04*n.v**2 + self.x*n.v + self.y - n.u + self.stim[i])            n.v += self.dt * 1/40.0 * (0.25*(n.v**2 + 110*n.v + 45*65) - n.u + self.stim[i])        #       n.u += self.dt * self.du(n.a,n.b,n.v,n.u)            n.u += self.dt * 0.015 * ( b * (n.v+65 ) - n.u )            p += self.dt / tau_p * ((n.v > 0)*tau_p/self.dt - p )            if n.v > 0:                trace[0,i] = 30                n.v        = -55                n.u       += 50            else:                trace[0,i] = n.v                trace[1,i] = n.u            if n.v < -65:                b = 10            else:                b=2            trace[2,i] = p        return trace
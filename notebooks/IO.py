from functions import *# c = ipp.Client(profile='cluster')# lview = c.load_balanced_view()# lview.block = Truedef xax(gamma, duration):    x= np.arange(0,(duration-1)/1000,(duration)/1000/len(gamma) )    return xclass IO(object):    def __init__(self):        self.computer = ""        self.executable_path = ""        self.data_path = ""        self.executable_name = ""        self.N = 100        self.r = 0        self.i = 0        self.g = 5        self.S = 100        self.d1 = 100        self.d2 = 1000        self.d3 = 100        self.WII = 1400        self.FACT = 1        self.ratio = 15        self.LTD = 1e-0 * 4.7e-6 * self.FACT * self.N        self.LTP = self.ratio * self.LTD        self.tauv = 15  # in ms, for 40Hz resonance        self.glob = 0  # 0 for local GJ, 1 otherwise        self.sG = 0  # number of shared GJ        self.sWII = 0  # number of shared chemical synapses        self.model = "gp-izh-subnetworks"  # neuron model        self.TImean = 30        self.sigma = 60  # colored noise mean        self.with_currents = False  # set to True to output LFP as current mean    def initTime(self):        self.before = self.d1        self.after = self.d2 + self.d3        self.T = self.d1 + self.d2 + self.d3    def getHist(self, data, binsize):        binnb = 0        val = []        for ind, i in enumerate(data):            if (ind % binsize) == 0:                if binnb > 0:                    val.append(accumulator)                accumulator = 0                binnb += 1            else:                accumulator += i        return val    # def check_connection(self):    #     print('Number of workers: %d' % len(c.ids))    def runPSTH(self, it=8):        Parallel(n_jobs=num_cores)(delayed(self.runSimulation)(i) for i in range(it))    def readPSTH(self, it,                 binsize, coeff, RON='izh', tau_m=10):        gr = GRAPH()        listSSP1 = Parallel(n_jobs=num_cores)(delayed(self.readSimulationSSP1)(i) for i in range(it))        if RON == 'izh':            listS = Parallel(n_jobs=num_cores)(delayed(gr.readoutSpikes)(ssp1, coeff, tau_m) for ssp1 in listSSP1)        else:            listS = Parallel(n_jobs=num_cores)(delayed(gr.readoutSpikesIAF)(ssp1, coeff, tau_m) for ssp1 in listSSP1)        tot = np.sum(listS, axis=0)        totSSP1 = np.sum(listSSP1, axis=0)        total = np.sum(listS)        h = self.getHist(tot, binsize)        hSSP1 = self.getHist(totSSP1, binsize)        spikes_x, spikes_y, spikes_x_tc, spikes_y_tc, gamma, correlation, ssp1, stimulation, p, q, lowsp, vm = self.readSimulation(            0)        return h, stimulation, total, hSSP1, totSSP1    def runSimulation(self, i=0):        ext = "_%d.txt" % i        sh.cd(self.executable_path)        commandStr = [self.executable_name, '-N', str(self.N), '-ext', str(ext),                      '-d1', str(self.d1), '-d2', str(self.d2), '-d3', str(self.d3),                      '-before', str(self.before), '-after', str(self.after),                      '-S', str(self.S), '-G', str(self.g), '-s', str(self.sigma),                      '-WII', str(self.WII), '-LTP', str(self.LTP), '-LTD', str(self.LTD),                      '-model', self.model, '-r', str(self.r), '-global', str(self.glob),                      '-sG', str(self.sG), '-sWII', str(self.sWII), '-tauv', str(self.tauv)]        print(' '.join(commandStr))        subprocess.check_output(commandStr)    def readSimulationSSP1(self, i=0):        DIRECTORY = self.data_path        ext = "_%d.txt" % i        # compute the paths of data files.        extension = "_g-%.6g_TImean-%d_T-%d_Glob-%d_dt-0.25_N-%d_r-%.2g_S-%d_WII-%d_LTD-%.6g_LTP-%.6g_model-%s_sG-%d_sWII-%d_tauv-%d" \                    % (self.g, self.TImean, self.T, self.glob, self.N, self.r, self.S, self.WII, self.LTD, self.LTP,                       self.model, self.sG, self.sWII, self.tauv)        extension += ext        ssp1_p = DIRECTORY + "sspE" + extension        ssp1 = np.fromfile(ssp1_p, dtype='double', count=-1, sep=" ")        return ssp1    def readMatrix(self, i=0, type="GAP"):        DIRECTORY = self.data_path        # simulation parameters        ext = "_%d.txt" % i        # compute the paths of data files.        extension = "_g-%.6g_TImean-%d_T-%d_Glob-%d_dt-0.25_N-%d_r-%.2g_S-%d_WII-%d_LTD-%.6g_LTP-%.6g_model-%s_sG-%d_sWII-%d_tauv-%d" \                    % (self.g, self.TImean, self.T, self.glob, self.N, self.r, self.S, self.WII, self.LTD, self.LTP,                       self.model, self.sG, self.sWII, self.tauv)        extension += ext        path_GAP = DIRECTORY + type + extension        with open(path_GAP) as file:            array2d = [[float(digit) for digit in line.split()] for line in file]        return array2d    def readSimulation(self, i=0):        T = self.d1 + self.d2 + self.d3        DIRECTORY = self.data_path        # simulation parameters        TImean = 30        ext = "_%d.txt" % i        # compute the paths of data files.        extension = "_g-%.6g_TImean-%d_T-%d_Glob-%d_dt-0.25_N-%d_r-%.2g_S-%d_WII-%d_LTD-%.6g_LTP-%.6g_model-%s_sG-%d_sWII-%d_tauv-%d" \                    % (self.g, TImean, T, self.glob, self.N, self.r, self.S, self.WII, self.LTD, self.LTP, self.model,                       self.sG, self.sWII, self.tauv)        extension += ext        path_x = DIRECTORY + "spike_x" + extension        path_x_tc = DIRECTORY + "spike_x_tc" + extension        path_y = DIRECTORY + "spike_y" + extension        path_y_tc = DIRECTORY + "spike_y_tc" + extension        path_g = DIRECTORY + "gamma" + extension        path_c = DIRECTORY + "correlation" + extension        ssp1_p = DIRECTORY + "sspE" + extension        p_p = DIRECTORY + "p" + extension        q_p = DIRECTORY + "q" + extension        lowsp_p = DIRECTORY + "LowSp" + extension        vm_p = DIRECTORY + "vm" + extension        i1_p = DIRECTORY + "current1" + extension        i2_p = DIRECTORY + "current2" + extension        # RON_I_p = DIRECTORY +"RON_I"+ extension        # RON_V_p = DIRECTORY +"RON_V"+ extension        # V_p = DIRECTORY +"V"+ extension        stimulation_p = DIRECTORY + "stimulation" + extension        #     print path_g        try:            self.spikes_x = np.fromfile(path_x, dtype='uint', count=-1, sep=" ")            self.spikes_x_tc = np.fromfile(path_x_tc, dtype='uint', count=-1, sep=" ")            self.spikes_y = np.fromfile(path_y, dtype='uint', count=-1, sep=" ")            self.spikes_y_tc = np.fromfile(path_y_tc, dtype='uint', count=-1, sep=" ")            self.gamma = np.fromfile(path_g, dtype='double', count=-1, sep=" ")            self.correlation = np.fromfile(path_c, dtype='double', count=-1, sep=" ")            self.ssp1 = np.fromfile(ssp1_p, dtype='double', count=-1, sep=" ")            self.p = np.fromfile(p_p, dtype='double', count=-1, sep=" ")            self.q = np.fromfile(q_p, dtype='double', count=-1, sep=" ")            self.LowSp = np.fromfile(lowsp_p, dtype='double', count=-1, sep=" ")            self.vm = np.fromfile(vm_p, dtype='double', count=-1, sep=" ")            if self.with_currents:                self.i1 = np.fromfile(i1_p, dtype='double', count=-1, sep=" ")                self.i2 = np.fromfile(i2_p, dtype='double', count=-1, sep=" ")            self.stimulation = np.fromfile(stimulation_p, dtype='double', count=-1, sep=" ")        except:            print('can\' find:\t ' + path_g)        return 0class Cortex(IO):    def __init__(self, *args, **kwargs):        super(Cortex, self).__init__(*args, **kwargs)        self.computer = "GP1514"        self.executable_path = "/Users/%s/Dropbox/ICL-2014/Code/C-Code/cortex/cortex/" % self.computer        self.data_path = "/Users/%s/Dropbox/ICL-2014/Code/C-Code/cortex/data/" % self.computer        self.executable_name = './cortex'class TRN(IO):    def __init__(self):        self.computer = "GP1514"        self.executable_path = "/Users/%s/Dropbox/ICL-2014/Code/C-Code/TRN/TRN/" % self.computer        self.data_path = "/Users/%s/Dropbox/ICL-2014/Code/C-Code/TRN/data/" % self.computer        self.executable_name = './trn'class GRAPH():    def __init__(self, cortex):        self.cortex = cortex    def readoutneuroncortex(self, ax, ssp1, Rm, W=-200, x=None):        dt = 0.25        bTh = 1.3        T = len(ssp1) / 4  # total time to simulate (msec)        time = np.arange(0, T, dt)        n = IzhNeuron("Burst Mode", a=0.02, b=0.25, c=-50, d=2, v0=-70)        s1 = IzhSim(n, T=T, dt=dt)        for i, t in enumerate(time):            s1.stim[i] = W * ssp1[i]        res = s1.integrate()        ax.set_ylim([-150, 30])        ax.spines['left'].set_position('zero')        ax.spines['right'].set_color('none')        # ax.spines['bottom'].set_position('zero')        ax.spines['top'].set_color('none')        ax.xaxis.set_ticks_position('bottom')        ax.yaxis.set_ticks_position('left')        if x:            ax.set_xlabel('Time (msec)')        else:            ax.set_xticks([])        ax.plot(s1.t, res[0], label='membrane voltage [mV]')        return ax    def readoutSpikes(self, ssp1, W=-200):        dt = 0.25        T = len(ssp1) / 4  # total time to simulate (msec)        time = np.arange(0, T, dt)        # n = IzhNeuron("Burst Mode", a=0.02, b=0.25, c=-50, d=2, v0=-70)        n = IzhNeuron("(A) tonic spiking", a=0.02, b=0.2, c=-65, d=6, v0=-70)        s1 = IzhSim(n, T=T, dt=dt)        for i, t in enumerate(time):            s1.stim[i] = W * ssp1[i]        res = s1.integrate()        spikes = res[0] > 0        return spikes    def readoutSpikesIAF(self, ssp1, W, tau_m=10):        ## setup parameters and state variables        T = len(ssp1) / 4  # total time to simulate (msec)        dt = 0.25  # simulation time step (msec)        time = np.arange(0, T, dt)  # time array        t_rest = 0  # initial refractory time        ## LIF properties        Vm = np.zeros(len(time))  # potential (V) trace over time        Rm = W  # resistance (kOhm)        Cm = 7  # capacitance (uF)        tau_m = tau_m  # time constant (msec)        tau_ref = 4  # refractory period (msec)        Vth = 1  # spike threshold (V)        V_spike = 0.5  # spike delta (V)        ## Stimulus        I = ssp1  # input current (A)        ## iterate over each time step        for i, t in enumerate(time):            if t > t_rest:                Vm[i] = Vm[i - 1] + (-Vm[i - 1] + I[i] * Rm) / tau_m * dt            if Vm[i] >= Vth:                Vm[i] += V_spike                t_rest = t + tau_ref        # plt.plot(Vm)        spikes = Vm > 1.1        return spikes    def findindex(self, val, spikes_x, start=0):        result = spikes_x[-1]        for i in range(start, len(spikes_x)):            if spikes_x[i] == val or spikes_x[i] > val:                result = i                break        return result    def plotraster(self, ax, spikes_x, spikes_y, i1, i2, x=0):        spx = spikes_x[i1:i2]        spy = spikes_y[i1:i2]        ax.spines['right'].set_color('none')        ax.spines['top'].set_color('none')        ax.xaxis.set_ticks_position('bottom')        ax.yaxis.set_ticks_position('left')        #     ax.set_ylim([0,100])        if x == 0:            ax.set_xticks([])        else:            ax.set_xlabel('Time (msec)')        ax.plot(spx, spy, '.', markersize=2)    def plotPTSH(self, fig, before, after, binsize, h, s, it, DIRECTORY, S, N):        T = before + after        simsize = T / 0.25        x2 = np.arange(0, (simsize / 4 - 1) / 1000, (simsize / len(s) / 4) / 1000)        # fig = plt.figure(figsize=(9,5))        gs = gridspec.GridSpec(2, 1, height_ratios=[3, 1])        ax0 = plt.subplot(gs[0])        # ax0.set_ylim([0,10])        ax0.bar(np.arange(0, simsize / 1000, simsize / len(h) / 1000), np.array(h) / it, binsize / 1000)        ax0.set_title('PSTH - Input: %s' % S)        ax0.set_xticks([])        # plot stimulation s        ax = plt.subplot(gs[1])        ax.set_ylim([30, 110])        ax.set_yticks([30, 100])        ax.set_xlabel('Time [s]')        plt.plot(x2, s)        plt.tight_layout()        extension = "_S-%d_N-%d_T-%d" % (S, N, T)        print(DIRECTORY + extension + '_PTSH.pdf')        plt.savefig(DIRECTORY + extension + '_PTSH.pdf')    def plotDiagram2(self, figure, ax, dataframe, title, column, filename, save=True, front=False, gridsize=60):        ax.set_ylim(ymin=50, ymax=250)        # Set color transparency (0: transparent; 1: solid)        a = 1        # Create a colormap        customcmap = [(x / 24.0, x / 48.0, 0.05) for x in range(len(dataframe))]        dataframe.plot(kind="hexbin",                       y='nuEI', x='gammaC', C=column, gridsize=gridsize, ax=ax, alpha=a, legend=False, colormap=cx4,                       # edgecolor='w',                       title=title)        ax.set_title(title, y=1.03)        # Customize title, set position, allow space on top of plot for title        # ax.set_title(ax.get_title(), fontsize=36, alpha=a)        # ax.title.set_fontsize(36)        plt.subplots_adjust(top=0.9)        # ax.title.set_position((0,1.08))        # Set x axis label on top of plot, set label text        ax.xaxis.set_label_position('bottom')        ax.set_xlim([0, 7])        xlab = r'$\gamma_C$'        ylab = r'$\nu_{EI}$'        ax.set_xlabel(xlab, alpha=a)        ax.set_ylabel(ylab, alpha=a)        ax.set_xticklabels(ax.get_xticks(), alpha=a)        ax.set_yticklabels(ax.get_yticks(), alpha=a)        # plasticity trajectory        # x = spikingSimulation.gamma*spikingSimulation.N_I        # y = (spikingSimulation.stimulation+neuronI.N_mean)/(neuronI.V_th - neuronI.vReset)        # plt.plot(x,y)        if front:            dataframe['logburst'] = (dataframe['burst']).apply(np.log10)            df_sliced = dataframe[(dataframe['logburst'] > -6) & (dataframe['logburst'] < -5.8)]            contour = df_sliced[['gammaC', 'nuEI']].get_values()            yvals, xvals = self.bezier_curve(contour, nTimes=100)            frontier = np.array([xvals, yvals])            ax.plot(frontier[1, :], frontier[0, :], '-w', linewidth=3)        if save:            plt.tight_layout()            plt.savefig(DIRECTORY + filename)        return ax    def plotDiagram(self, figure, ax, dataframe, title, column, filename, save=True, front=False, gridsize=60,                    extent=[0, 7.0, 0, 200], cmap=cx4, bad=False, format=None):        ax.set_ylim(ymin=extent[2], ymax=extent[3])        # Set color transparency (0: transparent; 1: solid)        a = 1        # Create a colormap        customcmap = [(x / 24.0, x / 48.0, 0.05) for x in range(len(dataframe))]        dataframe = dataframe.fillna(0)        nbVal = len(pd.unique(dataframe.nuEI.ravel()))        da = np.array(dataframe[['gammaC', 'nuEI', column]].sort_values(['nuEI', 'gammaC'], ascending=[0, 1]))        z = da[:, 2]        # print(z.shape)        try:            zr = z.reshape(nbVal, len(z) / nbVal)            print(zr.shape)            if bad:                cmap.set_bad('white')                plt.imshow(np.ma.masked_values(zr, 0), cmap=cmap)            image = ax.imshow(zr, extent=extent, cmap=cmap, aspect=(extent[1] - extent[0]) / (            extent[3] - extent[2]))  # , cmap =cx4)# drawing the function            if format == None:                plt.colorbar(image, format='%.2g')            else:                plt.colorbar(image, format=format)            # ax.plot(frontier[1,:], frontier[0,:], '-w', linewidth=2)            ax.set_title(title, y=1.03)            # Customize title, set position, allow space on top of plot for title            # ax.set_title(ax.get_title(), fontsize=36, alpha=a)            # ax.title.set_fontsize(36)            plt.subplots_adjust(top=0.9)            # ax.title.set_position((0,1.08))            # Set x axis label on top of plot, set label text            ax.xaxis.set_label_position('bottom')            maxX = math.floor(extent[1] * 10) / 10            maxY = math.ceil(extent[3] / 10) * 10            ax.set_xlim([extent[0], maxX])            ax.set_yticks([extent[2], (maxY - extent[2]) / 2, maxY])            ax.set_xticks([extent[0], (maxX - extent[0]) / 2, maxX])            xlab = r'Gap-junctions $\gamma_C$'            ylab = r'Mean drive $\nu_{EI}$'            ax.set_xlabel(xlab, alpha=a)            ax.set_ylabel(ylab, alpha=a)            ax.set_xticklabels(ax.get_xticks(), alpha=a)            ax.set_yticklabels(ax.get_yticks(), alpha=a)            # plasticity trajectory            # x = spikingSimulation.gamma*spikingSimulation.N_I            # y = (spikingSimulation.stimulation+neuronI.N_mean)/(neuronI.V_th - neuronI.vReset)            # plt.plot(x,y)            if front:                dataframe['logburst'] = (dataframe['burst']).apply(np.log10)                df_sliced = dataframe[(dataframe['logburst'] > -6) & (dataframe['logburst'] < -5.8)]                contour = df_sliced[['gammaC', 'nuEI']].get_values()                yvals, xvals = self.bezier_curve(contour, nTimes=100)                frontier = np.array([xvals, yvals])                ax.plot(frontier[1, :], frontier[0, :], '-w', linewidth=3)            if save:                plt.tight_layout()                plt.savefig(DIRECTORY + filename)        except:            print('Error reshaping array')        return ax    def plotDiagramCSD(self, figure, ax, dataframe, title, column, filename, save=True, front=False, gridsize=60,                        extent=[0, 7.0, 0, 200], cmap=cx4, bad=False, format=None):        ax.set_ylim(ymin=extent[2], ymax=extent[3])        # Set color transparency (0: transparent; 1: solid)        a = 1        # Create a colormap        customcmap = [(x / 24.0, x / 48.0, 0.05) for x in range(len(dataframe))]        dataframe = dataframe.fillna(0)        nbVal = len(pd.unique(dataframe.tauv.ravel()))        da = np.array(dataframe[['sG', 'tauv', column]].sort_values(['sG', 'tauv'], ascending=[0, 0]))        z = da[:, 2]        # print(z.shape)        try:            zr = z.reshape(nbVal, len(z) / nbVal)            print(zr.shape)            if bad:                cmap.set_bad('white')                plt.imshow(np.ma.masked_values(zr, 0), cmap=cmap)            image = ax.imshow(zr, extent=extent, cmap=cmap, interpolation='nearest',                              aspect=(extent[1] - extent[0]) / (extent[3] - extent[2]))  # , cmap =cx4)# drawing the function            if format == None:                plt.colorbar(image, format='%.2g')            else:                plt.colorbar(image, format=format)            ax.set_title(title, y=1.03)            plt.subplots_adjust(top=0.9)            ax.xaxis.set_label_position('bottom')            maxX = math.floor(extent[1] * 10) / 10            maxY = math.ceil(extent[3] / 10) * 10            ax.set_xlim([extent[0], maxX])            ax.set_yticks([extent[2], (maxY - extent[2]) / 2, maxY])            ax.set_xticks([extent[0], (maxX - extent[0]) / 2, maxX])            xlab = r'Nb of shared Gap-junctions'            ylab = r'Time constant $\tau_{v}$'            ax.set_xlabel(xlab, alpha=a)            ax.set_ylabel(ylab, alpha=a)            ax.set_xticklabels(ax.get_xticks(), alpha=a)            ax.set_yticklabels(ax.get_yticks(), alpha=a)            if save:                plt.tight_layout()                plt.savefig(DIRECTORY + filename)        except:            print('Error reshaping array')        return ax    def savePTSH(self, before, after, h, s, it, DIRECTORY, S, N):        '''        Save PTSH data        '''        T = before + after        simsize = len(s)        print(T / 1000, simsize, T / 1000 / simsize)        x2 = np.arange(0, T / 1000, T / 1000 / simsize)        extension = "_S-%d_N-%d_T-%d" % (S, N, T)        np.save(DIRECTORY + extension + '_data.npy', np.array([np.arange(len(h)), np.array(h) / it]))    def func(self, x, a, b, c):        return a * np.exp(-b * x) + c    def plotRaster(self, spikes_x, spikes_y, ax=None, titlestr=""):        if not ax:            f = plt.figure(figsize=(4, 3))            ax = f.add_subplot(111)        # ax.set_xticks([])        # ax.set_yticks([0,300])        # ax.set_xlabel('Time [1.5s]')        # ax.set_ylabel('Neuron indices [0-300]')        # ax.set_title('Neuronal Activity')        if ax == None:            plt.plot(spikes_x, spikes_y, '.', markersize=1, color='grey')            plt.title(titlestr, y=1.08)        else:            ax.plot(spikes_x, spikes_y, '.', markersize=1, color='grey')            ax.set_title(titlestr, y=1.08)        return ax        # plt.savefig(DIRECTORY + extension + '_raster.pdf')        # plt.savefig(DIRECTORY + extension + '_raster.png')    def plotRasterGPU(self, spikes_x, spikes_y, titlestr="", saveImg=0):        '''        Take advantage of WebGL to draw raster plot        '''        # output_file("spikesGPU.html", title="Neural activity")        p = figure(plot_width=1000, plot_height=500, webgl=True, title=titlestr)        if len(spikes_x) > 100000:            p.scatter(spikes_x[0:100000], spikes_y[0:100000], alpha=0.5)        else:            p.scatter(spikes_x, spikes_y, alpha=0.5)        save(p, filename=titlestr) if saveImg else show(p)    def fourier(self, signal):        f_val, p_val = self.maxPowerFreq(signal[int(signal.shape[0] / 2):], 0.25 / 1000)        return [f_val, p_val]    def maxPowerFreq(self, y, dt):        # return the max power of the signal and its associated frequency        fs = 1. / dt        y = y - np.mean(y)        t = np.arange(0, y.shape[0], 1)        p1, f1 = psd(y, NFFT=len(t), pad_to=len(t), Fs=fs)        powerVal = 10 * np.log10(max(p1))        powerFreq = np.argmax(p1) * np.max(f1) / len(f1)        return powerFreq, powerVal    def bernstein_poly(self, i, n, t):        """         The Bernstein polynomial of n, i as a function of t        """        return comb(n, i) * (t ** (n - i)) * (1 - t) ** i    def bezier_curve(self, points, nTimes=1000):        """           Given a set of control points, return the           bezier curve defined by the control points.           points should be a list of lists, or list of tuples           such as [ [1,1],                     [2,3],                     [4,5], ..[Xn, Yn] ]            nTimes is the number of time steps, defaults to 1000            See http://processingjs.nihongoresources.com/bezierinfo/        """        nPoints = len(points)        xPoints = np.array([p[0] for p in points])        yPoints = np.array([p[1] for p in points])        t = np.linspace(0.0, 1.0, nTimes)        polynomial_array = np.array([self.bernstein_poly(i, nPoints - 1, t) for i in range(0, nPoints)])        xvals = np.dot(xPoints, polynomial_array)        yvals = np.dot(yPoints, polynomial_array)        return xvals, yvals    def frontgamma(self, nuEI, frontier, tol=10):        '''        Return the value of GAMMA for a value of NUEI        '''        indices = np.where(np.logical_and(frontier[0] <= nuEI + tol, frontier[0] >= nuEI - tol))        return np.mean(frontier[1][indices[0]])    def find_nearest(self, array, value, dataframe):        gamma = (pd.unique(dataframe['gammaC']))        idx = (np.abs(array - value)).argmin()        return array[idx], idx, gamma[idx]    def fixpoint(self, df, nuEI, ratio, rule, g0=5):        '''        Search and return the fix point for a plasticity rule, or 0 if none        :param df:        :param nuEI:        :param ratio:        :param rule: [1 hardbound        2 softbound passive        3 softbound spiking no bursting        4 hardbound passive        5 hardbound spiking non bursting]        :param g0:        :return:        '''        LTP = 10        LTD = LTP * ratio        df_sliced = df[df['nuEI'] == nuEI]        df_sliced = df_sliced.sort_values(by=['gammaC'])        bg = df_sliced[['burst', 'gammaC']].get_values()        sg = df_sliced[['spike', 'gammaC']].get_values()        rg = df_sliced[['non-burst', 'gammaC']].get_values()        df_sliced['passive'] = df_sliced['burst'].apply(lambda x: 1 - x)        passive = df_sliced[['passive', 'gammaC']].get_values()        #     sg = 1 - np.array(bg)        cg = df_sliced[['corI', 'gammaC']].get_values()        if rule == 1:            dG = LTP * sg[:, 0] - LTD * bg[:, 0]        elif rule == 4:            dG = LTP * passive[:, 0] - LTD * bg[:, 0]        elif rule == 5:            dG = LTP * rg[:, 0] - LTD * bg[:, 0]        elif rule == 0:            dG = LTP * (g0 - sg[:, 1]) / g0 * sg[:, 0] - LTD * bg[:, 0]        elif rule == 2:            dG = LTP * (g0 - passive[:, 1]) / g0 * passive[:, 0] - LTD * bg[:, 0]        elif rule == 3:            dG = LTP * (g0 - rg[:, 1]) / g0 * rg[:, 0] - LTD * bg[:, 0]        res = 0        dg2 = np.array(dG)        if (dg2 > 0).all() or (dg2 < 0).all():            res = 0        else:            minval, idx, _ = self.find_nearest(dg2, 0, df)            res = sg[idx, 1]        return res    def overunder(self, df, frontier, rule):        '''        return 0 if fixpoint over in the SYNC regime, 1 otherwise        '''        if rule in [0, 1, 5, 3]:            col = np.arange(3, 5, 0.05)  # ratio for active rule        else:            col = np.arange(60, 180, 3)  # ratio for passive rule        row = np.arange(0, 200, 1)  # nu        Z = np.zeros(shape=(len(row), len(col)))        for i, ratio in enumerate(col):            for j, nuEI in enumerate(row):                f = self.fixpoint(df, nuEI, ratio, rule)                border = self.frontgamma(nuEI, frontier)                Z[len(row) - 1 - j, i] = abs(f - border) * ((f < border) and (f > 0.15) and (nuEI > 48)) * 1.0        return Z    def plotStability(self, ax, Z, ylabel, title, extent):        cx_blue = cubehelix.cmap(reverse=False, start=3., rot=0)        ax.set_xlabel('ratio')        ax.set_ylabel(r'Excitatory input $\nu$')        ax.set_title('Hard. all-spiking', y=1.08)        image = ax.imshow(Z, interpolation='nearest', extent=extent, cmap=cx_blue,                          aspect=2 / 200)  # , cmap =cx4)# drawing the function        plt.colorbar(image)        return ax    def plotWeights(self, tauv=15):        c = self.cortex        titlestr = r'$N=%d$  $\frac{\alpha_{LTP}}{\alpha_{LTD}}=%d$  $g_0=%.1f$  $\nu=%d$ $sG=%d$ $sW_{II}=%d$ $LTD=%.6g$ $\tau_v=%d$' \                   % (c.N, c.r, c.g, c.sigma, c.sG, c.sWII, c.LTD, c.tauv)        GAP2D = c.readMatrix(type="GAP")        GAP2D0 = c.readMatrix(type="GAP0")        WII2D = c.readMatrix(type='WII')        fig = plt.figure(figsize=(12, 14))        fontsize = 10        matplotlib.rc('xtick', labelsize=fontsize)        matplotlib.rc('ytick', labelsize=fontsize)        matplotlib.rc('axes', labelsize=fontsize)        matplotlib.rc('axes', titlesize=fontsize)        ax0 = fig.add_subplot(421)        ax0.plot(xax(c.gamma, c.T), c.gamma, color='c')        ax01 = fig.add_subplot(422)        T = 2000        dt = 1        t = np.arange(0, T, dt)        F = np.logspace(0.5, 2.3, 200)        mod = resonanceFS(F, tauv=tauv)        mod15 = resonanceFS(F, tauv=15)        ax01.semilogx(F, mod / np.nanmax(mod), label='%.1f' % (F[np.argmax(mod)]), color='c')        ax01.semilogx(F, mod15 / np.nanmax(mod15), label='%.1f' % (F[np.argmax(mod15)]), color='r')        ax01.set_ylim([0, 1.05])        # plt.legend()        ax01.set_xlabel('Stimulus Frequency [Hz]')        ax01.set_ylabel('Normalised Response Amplitude')        ax01.set_xlim([0, 200])        ax01.set_title('Subthreshold Resonant Property', y=1.08)        ax01.legend()        # --------------------------------------------------------------------------------        # PLot weights        # --------------------------------------------------------------------------------        ax1 = plt.subplot(434)        # plt.imshow(np.array(GAP2D)[100:150,1:20], interpolation='nearest')        im1 = ax1.imshow(np.array(GAP2D0), interpolation='nearest')        ax1.set_title(r'$\gamma(t = 0)$')        fig.colorbar(im1)        # plt.figure(figsize=(10,10))        ax2 = plt.subplot(435)        im2 = ax2.imshow(np.array(GAP2D), interpolation='nearest')        ax2.set_title(r'$\gamma(t = END)$')        fig.colorbar(im2)        # plt.figure(figsize=(10,10))        ax3 = plt.subplot(436)        im3 = ax3.imshow(np.array(WII2D), interpolation='nearest')        ax3.set_title(r'$W_{II}$')        #--------------------------------------------------------------------------------        # RASTER PLOT begin and end of simulation        #--------------------------------------------------------------------------------        ax1 = fig.add_subplot(425)        ax2 = fig.add_subplot(426)        self.plotRaster(c.spikes_x[:5000], c.spikes_y[:5000], ax=ax1)        self.plotRaster(c.spikes_x[-5000:], c.spikes_y[-5000:], ax=ax2)        #--------------------------------------------------------------------------------        # Cross Spectrum Gaph        #--------------------------------------------------------------------------------        ax7 = fig.add_subplot(427)        ax8 = fig.add_subplot(428)        ax7 = self.plotCSD(c.i1, c.i2, start=0, end=4000, ax=ax7, sharey=True)        ax8 = self.plotCSD(c.i1, c.i2, start=-4000, end=-1, ax=ax8, sharey=True)        plt.suptitle(titlestr)        plt.savefig(DIRECTORY + "full_sWII-%d_sG-%d_WII-%d_G-%d_N-%d_t-%d_LTD-%d_tauv-%d" % (            c.sWII, c.sG, c.WII, c.g, c.N, c.T, c.LTD > 1e-8, c.tauv))        del fig        # gr.plotRasterGPU(spikes_x[:],spikes_y[:], "test_%s.html"%(str(G)), saveImg=0)        return 0    def plotCSD(self, i1, i2, start=0, end=4000, ax=None, sharey = None):        f, Pxy = signal.csd(i1[start:end], i2[0:2000], fs=1 / 0.00025, nperseg=1024)        if sharey:            f2, Pxy2 = signal.csd(i1[-2000:-1], i2[-2000:-1], fs=1 / 0.00025, nperseg=1024)            ax.plot(f, np.abs(Pxy) )            ax.set_ylim([0, max(np.max(np.abs(Pxy2)), np.max(np.abs(Pxy)))])        else:            ax.plot(f, np.abs(Pxy))        ax.set_xlabel('frequency [Hz]')        ax.set_ylabel('CSD [V**2/Hz]')        ax.set_xlim([0, 300])        ax.set_title('Cross-spectrum between LFPs of 2 networks')        return ax    def valCSD(self,):        '''        Return the max value of the CSD at the beginning and at the end of the simulation        :param i1:        :param i2:        :return:        '''        dictRes = {}        c = self.cortex        f, Pxy = signal.csd(c.i1[0:4000], c.i2[0:4000], fs=1 / 0.00025, nperseg=1024)        f2, Pxy2 = signal.csd(c.i1[-4000:-1], c.i2[-4000:-1], fs=1 / 0.00025, nperseg=1024)        maxBegin = np.max(np.abs(Pxy))        argmaxBegin = np.argmax(np.abs(Pxy))        maxEnd = np.max(np.abs(Pxy2))        argamxEnd = np.max(np.abs(Pxy2))        dictRes = {'maxBegin': maxBegin, 'argmaxBegin': argmaxBegin, 'maxEnd': maxEnd, 'argmaxEnd': argamxEnd}        dictRes['f1Begin'] = self.fourier(c.i1[0:4000])        dictRes['f2Begin'] = self.fourier(c.i2[0:4000])        dictRes['f1End'] = self.fourier(c.i1[-4000:-1])        dictRes['f2End'] = self.fourier(c.i2[-4000:-1])        return dictRes################################################################################# Classes################################################################################class IzhNeuron:    def __init__(self, label, a, b, c, d, v0, u0=None):        self.label = label        self.a = a        self.b = b        self.c = c        self.d = d        self.v = v0        self.u = u0 if u0 is not None else b * v0class IzhSim:    def __init__(self, n, T, dt=0.1):        self.neuron = n        self.dt = dt        self.t = t = np.arange(0, T + dt, dt)        self.stim = np.zeros(len(t))        self.x = 5        self.y = 140        self.du = lambda a, b, v, u: a * (b * v - u)    def integrate(self, n=None):        if n is None: n = self.neuron        trace = np.zeros((3, len(self.t)))        b = 2        p = 0        tau_p = 10        for i, j in enumerate(self.stim):            #       n.v += self.dt * (0.04*n.v**2 + self.x*n.v + self.y - n.u + self.stim[i])            n.v += self.dt * 1 / 40.0 * (0.25 * (n.v ** 2 + 110 * n.v + 45 * 65) - n.u + self.stim[i])            #       n.u += self.dt * self.du(n.a,n.b,n.v,n.u)            n.u += self.dt * 0.015 * (b * (n.v + 65) - n.u)            p += self.dt / tau_p * ((n.v > 0) * tau_p / self.dt - p)            if n.v > 0:                trace[0, i] = 30                n.v = -55                n.u += 50            else:                trace[0, i] = n.v                trace[1, i] = n.u            if n.v < -65:                b = 10            else:                b = 2            trace[2, i] = p        return trace